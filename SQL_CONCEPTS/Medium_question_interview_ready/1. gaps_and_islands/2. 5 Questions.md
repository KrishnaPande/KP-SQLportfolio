Excellent. Iâ€™ll do this **properly**, not toy questions.

Below are **5 interview-level SQL questions**, each **one level harder than the previous**, all designed to **burn the gaps & islands logic into your brain**.

ðŸ‘‰ **Do NOT solve now**.
Your job is to **read, visualize, and explain the approach mentally**.

---

# ðŸ§  LEVEL 1 â€” Daily Continuity (Foundation)

### Table: `user_logins`

| user_id | login_ts         |
| ------- | ---------------- |
| 1       | 2024-01-01 10:00 |
| 1       | 2024-01-02 09:00 |
| 1       | 2024-01-04 11:00 |
| 2       | 2024-01-01 08:00 |
| 2       | 2024-01-02 08:30 |
| 2       | 2024-01-03 09:00 |

### Question

For each user, find **continuous daily login streaks** and return:

* streak_start_date
* streak_end_date
* streak_length (in days)

### What this tests

* Timestamp â†’ date normalization
* Basic gaps & islands

---

# ðŸ§  LEVEL 2 â€” Multiple Events per Day (Real-world data)

### Table: `user_purchases`

| user_id | purchase_ts      | amount |
| ------- | ---------------- | ------ |
| 1       | 2024-01-01 10:00 | 50     |
| 1       | 2024-01-01 18:00 | 30     |
| 1       | 2024-01-02 11:00 | 40     |
| 1       | 2024-01-04 09:00 | 20     |

### Question

Identify **daily purchase streaks** per user and return:

* streak_start_date
* streak_end_date
* total_revenue
* avg_daily_revenue

### Constraints

* Multiple purchases per day
* One row per streak

### What this tests

* Pre-aggregation
* Correct â€œdailyâ€ interpretation

---

# ðŸ§  LEVEL 3 â€” Monthly Activity Across Years (Indexing skill)

### Table: `subscription_activity`

| user_id | activity_date |
| ------- | ------------- |
| 1       | 2023-11-10    |
| 1       | 2023-12-05    |
| 1       | 2024-01-02    |
| 1       | 2024-03-15    |
| 2       | 2024-01-01    |
| 2       | 2024-02-01    |

### Question

Find **continuous active months** per user.

Return:

* user_id
* start_month
* end_month
* number_of_months

### What this tests

* Month indexing (`year * 12 + month`)
* Cross-year continuity

---

# ðŸ§  LEVEL 4 â€” Business-Defined Breaks (Lag + flag)

### Table: `user_sessions`

| user_id | session_start    |
| ------- | ---------------- |
| 1       | 2024-01-01 10:00 |
| 1       | 2024-01-01 10:20 |
| 1       | 2024-01-01 11:30 |
| 1       | 2024-01-01 12:00 |

### Question

Define a **new session** if:

* gap between events > **30 minutes**

Return:

* user_id
* session_start
* session_end
* session_duration_minutes

### What this tests

* Epoch/minute indexing
* Dynamic break logic
* Why arithmetic islands fail here

---

# ðŸ§  LEVEL 5 â€” Conditional Islands (FAANG-level)

### Table: `user_revenue`

| user_id | event_date | revenue |
| ------- | ---------- | ------- |
| 1       | 2024-01-01 | 100     |
| 1       | 2024-01-02 | 120     |
| 1       | 2024-01-03 | 90      |
| 1       | 2024-01-04 | 95      |
| 1       | 2024-01-06 | 110     |

### Question

For each user, identify **revenue growth streaks** where:

* Dates are consecutive
* Revenue does **not decrease**
* A streak breaks if **either condition fails**

Return:

* streak_start_date
* streak_end_date
* streak_length
* total_revenue

### What this tests

* Multiple break conditions
* Lag comparisons + continuity
* Senior-level reasoning

---

## ðŸ”’ How to store this in your brain

Map levels to patterns:

| Level | Pattern                  |
| ----- | ------------------------ |
| 1     | Date âˆ’ row_number        |
| 2     | Aggregate â†’ Date islands |
| 3     | Month index âˆ’ row_number |
| 4     | Lag + flag + cumsum      |
| 5     | Multi-condition breaks   |

If you can **explain the approach** for all 5 without SQL,
you are **interview-ready**.

---

### Next step (recommended)

Pick **ONE level** and:

* explain approach verbally (no SQL)
* then write SQL

Iâ€™ll review it like a real interviewer.

---

Perfect. Below are **clean, interview-safe SQL solutions for all 5 levels**, written in a **standard, readable CTE structure**.
Iâ€™ll add **short comments only where it helps logic**, nothing extra.

Assume PostgreSQL / Snowflake-style SQL (syntax is easily portable).

---

# âœ… LEVEL 1 â€” Daily Login Streaks

### Goal

Continuous **daily** login streaks per user.

```sql
WITH daily_logins AS (
    SELECT
        user_id,
        login_ts::date AS login_date
    FROM user_logins
    GROUP BY user_id, login_ts::date
),
numbered AS (
    SELECT
        user_id,
        login_date,
        login_date - ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY login_date
        ) AS island_key
    FROM daily_logins
)
SELECT
    user_id,
    MIN(login_date) AS streak_start_date,
    MAX(login_date) AS streak_end_date,
    COUNT(*) AS streak_length
FROM numbered
GROUP BY user_id, island_key
ORDER BY user_id, streak_start_date;
```

---

# âœ… LEVEL 2 â€” Daily Purchase Streaks (Multiple Purchases per Day)

### Goal

Aggregate per day **before** finding streaks.

```sql
WITH daily_purchases AS (
    SELECT
        user_id,
        purchase_ts::date AS purchase_date,
        SUM(amount) AS daily_revenue
    FROM user_purchases
    GROUP BY user_id, purchase_ts::date
),
numbered AS (
    SELECT
        user_id,
        purchase_date,
        daily_revenue,
        purchase_date - ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY purchase_date
        ) AS island_key
    FROM daily_purchases
)
SELECT
    user_id,
    MIN(purchase_date) AS streak_start_date,
    MAX(purchase_date) AS streak_end_date,
    COUNT(*) AS streak_length,
    SUM(daily_revenue) AS total_revenue,
    AVG(daily_revenue) AS avg_daily_revenue
FROM numbered
GROUP BY user_id, island_key
ORDER BY user_id, streak_start_date;
```

---

# âœ… LEVEL 3 â€” Continuous Active Months (Across Years)

### Goal

Month continuity using **month index**.

```sql
WITH monthly_activity AS (
    SELECT DISTINCT
        user_id,
        DATE_TRUNC('month', activity_date) AS activity_month
    FROM subscription_activity
),
indexed AS (
    SELECT
        user_id,
        activity_month,
        (EXTRACT(YEAR FROM activity_month) * 12
         + EXTRACT(MONTH FROM activity_month)) -
        ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY activity_month
        ) AS island_key
    FROM monthly_activity
)
SELECT
    user_id,
    MIN(activity_month) AS start_month,
    MAX(activity_month) AS end_month,
    COUNT(*) AS number_of_months
FROM indexed
GROUP BY user_id, island_key
ORDER BY user_id, start_month;
```

---

# âœ… LEVEL 4 â€” Sessions with 30-Minute Break Rule

### Goal

Dynamic break â†’ **lag + flag + cumulative sum**

```sql
WITH ordered_events AS (
    SELECT
        user_id,
        session_start,
        EXTRACT(EPOCH FROM session_start
            - LAG(session_start) OVER (
                PARTITION BY user_id ORDER BY session_start
            )
        ) / 60 AS gap_minutes
    FROM user_sessions
),
flagged AS (
    SELECT
        user_id,
        session_start,
        CASE
            WHEN gap_minutes IS NULL OR gap_minutes > 30 THEN 1
            ELSE 0
        END AS new_session_flag
    FROM ordered_events
),
sessionized AS (
    SELECT
        user_id,
        session_start,
        SUM(new_session_flag) OVER (
            PARTITION BY user_id ORDER BY session_start
        ) AS session_id
    FROM flagged
)
SELECT
    user_id,
    MIN(session_start) AS session_start,
    MAX(session_start) AS session_end,
    EXTRACT(EPOCH FROM MAX(session_start) - MIN(session_start)) / 60
        AS session_duration_minutes
FROM sessionized
GROUP BY user_id, session_id
ORDER BY user_id, session_start;
```

---

# âœ… LEVEL 5 â€” Revenue Growth Streaks (FAANG-Level)

### Goal

Streak continues **only if**:

* dates are consecutive
* revenue does **not decrease**

```sql
WITH ordered AS (
    SELECT
        user_id,
        event_date,
        revenue,
        event_date - LAG(event_date) OVER (
            PARTITION BY user_id ORDER BY event_date
        ) AS day_gap,
        revenue - LAG(revenue) OVER (
            PARTITION BY user_id ORDER BY event_date
        ) AS revenue_diff
    FROM user_revenue
),
flagged AS (
    SELECT
        user_id,
        event_date,
        revenue,
        CASE
            WHEN day_gap = 1 AND revenue_diff >= 0 THEN 0
            ELSE 1
        END AS break_flag
    FROM ordered
),
islands AS (
    SELECT
        user_id,
        event_date,
        revenue,
        SUM(break_flag) OVER (
            PARTITION BY user_id ORDER BY event_date
        ) AS island_id
    FROM flagged
)
SELECT
    user_id,
    MIN(event_date) AS streak_start_date,
    MAX(event_date) AS streak_end_date,
    COUNT(*) AS streak_length,
    SUM(revenue) AS total_revenue
FROM islands
GROUP BY user_id, island_id
ORDER BY user_id, streak_start_date;
```

---

# ðŸ§  FINAL MEMORY LOCK (IMPORTANT)

If you forget SQL, remember this:

> **Normalize â†’ Order â†’ Detect break â†’ Accumulate â†’ Aggregate**

Arithmetic islands â†’ fixed continuity
Lag + flag â†’ business rules
Cumulative sum â†’ session / streak id

If you can **explain why each CTE exists**, you are **senior-level ready**.

---

If you want next:

* Iâ€™ll ask **follow-up interviewer traps** on these
* Or convert one into **spoken interview explanation**
* Or mix **two conditions together (date + metric + category)**

Just say the word.



